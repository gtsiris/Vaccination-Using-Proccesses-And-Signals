Ονοματεπώνυμο: Γεώργιος Τσίρης,  Αριθμός Μητρώου: 1115201700173

Περιγραφή:
Το πρόγραμμα αποτελεί υλοποίηση μιας κατανεμημένης βάσης δεδομένων στην οποία φυλάσσονται πληροφορίες για εμβολιασμούς πολιτών από διάφορες χώρες κατά διαφόρων
ασθενειών. Mε κριτήριο αυτές τις πληροφορίες εγκρίνεται ή απορρίπτεται το αίτημα του εκάστοτε πολίτη για ταξίδι προς την χώρα προοριμού του. Η γονική διεργασία
travelMonitor επικοινωνεί μέσω fifos (name pipes) και signals με τις διεργασίες-παιδιά monitors προκειμένου να εξυπηρετήσει τις εντολές που δέχεται από τον
χρήστη.

Πρωτόκολλο επικοινωνίας:
Υλοποιείται σε δύο επίπεδα: 1) Σε χαμηλό επίπεδο όπου με την χρήση κλήσεων συστήματος επιτυγχάνεται ραντεβού των δύο μερών για γράψιμο και ανάγνωση αντίστοιχα
το πολύ bufferSize bytes κάθε φορά. 2) Σε λίγο υψηλότερο επίπεδο όπου έχουμε αποστολή μηνύματος το πολύ pipeSize bytes (το END_OF_MESSAGE σηματοδοτεί το τέλος
του) και ακολούθως λήψη επιβεβαίωσης (ACK), ενώ υπάρχει και προσυμφωνημένο μήνυμα για αντιστροφή της κατεύθυνσης επικοινωνίας (STOP) ώστε να επιτευχθεί
συγχρονισμένη εναλλαγή από γράψιμο σε ανάγνωση και το αντίστροφο. Σχηματικά το πρωτόκολλο έχει ως εξής:
T:  bufferSize + END_OF_MESSAGE ->  :M
T:            <- ACK                :M
T:  sizeOfBloom + END_OF_MESSAGE -> :M
T:            <- ACK                :M
T:  inputDir + END_OF_MESSAGE ->    :M
T:            <- ACK                :M
T:  country1 + END_OF_MESSAGE ->    :M
T:            <- ACK                :M
T:  country... + END_OF_MESSAGE ->  :M
T:            <- ACK                :M
T:  countryN + END_OF_MESSAGE ->    :M
T:            <- ACK                :M
T:              STOP ->             :M     /* Παρατηρούμε ότι πριν το STOP ο T έστελνε και ο M επιβεβαίωνε, ενώ μετά το STOP ο M στέλνει και ο T επιβεβαιώνει */
T:     <- virus1 + END_OF_MESSAGE   :M
T:               ACK ->             :M
T:     <- bloom1 + END_OF_MESSAGE   :M
T:               ACK ->             :M
T:   <- virus... + END_OF_MESSAGE   :M
T:               ACK ->             :M
T:   <- bloom... + END_OF_MESSAGE   :M
T:               ACK ->             :M                                             όπου T: TravelMonitor και Μ: Monitor
T:     <- virusM + END_OF_MESSAGE   :M
T:               ACK ->             :M
T:     <- bloomM + END_OF_MESSAGE   :M
T:               ACK ->             :M
T:           <-  STOP               :M
T:            command ->            :M
T:            <- ACK                :M
T:              STOP ->             :M
T:          <- result               :M
T:               ACK ->             :M
T:               ...                :M

Προσθήκες στον κώδικα του project1:
- Η κλάση του αιτήματος ταξιδιού (class_Travel_Request.h) που αποτελείται από την ημερομηνία (date) του αιτήματος και το εάν έγινε δεκτό ή όχι (status).
- Μία επιπλέον λίστα travelRequests (στο class_Population_Status.h) όπου φυλάσσονται τα αιτήματα προς κάθε χώρα ανά ιό.
- Μικρές αλλαγές (πχ. το bitArray του bloom από int[] σε char[] για ευκολότερη μεταφορά μέσω τύπου string μηνυμάτων) και προσθήκες συναρτήσεων στις
  κλάσεις των ιών και των πληθυσμιακών στοιχείων (πχ. AddTravelRequest, TravelStatsBetween, κλπ).
- Δυνατότητα ενοποίησης ενός bloomFilter με κάποιο καινούργιο προκειμένου να γίνει ενημέρωση του, χωρίς να χάσει την προϋπάρχουσα πληροφορία.
  Αυτό επιτυγχάνεται με bitwise OR, καθώς τα bits που είναι 1 και άρα υποδεικνύουν αρνητική απάντηση παραμένουν 1 και μετά την χρήση της μάσκας.
- Μία δομή (struct_Monitor.h) στην οποία ο travelMonitor φυλάσσει πληροφορίες αναφορικά με το monitor που δημιουργεί όπως είναι ο αύξων αριθμός που το
  προσδιορίζει (monitorID), το process id της αντίστοιχης διεργασίας (pid) και τις χώρες (countries) που του έχουν ανατεθεί.
- Νέα travelMonitor και Monitor που επικοινωνούν με το παραπάνω πρωτόκολλο για την εξυπηρέτηση των επερωτήσεων του χρήστη.

Λεπτομέριες υλοποίησης:
- Τα bloomFilters των αντίστοιχων ιών ενοποιούνται όταν αυτά έρχονται από τα monitors στον travelMonitor με τον τρόπο που αναφέρθηκε προηγουμένως.
- Ένα αίτημα ταξιδιού θεωρείται έγκυρο αν τόσο η χώρα προέλευσης όσο και η χώρα προορισμού υπάρχουν στο inputDir και επίσης ο ιός έχει εντοπιστεί σε τουλάχιστον
  μία χώρα. Μόνο τα έγκυρα αιτήματα προσμετρόυνται στους μετρητές. Τέλος, αν στο monitor διαπιστωθεί ότι ο πολίτης έχει διαφορετική χώρα προορισμού από αυτήν
  που έχει δηλωθεί, τότε η απάντηση είναι αρνητική.
- Παραδοχή ότι 6 μήνες = 180 μέρες (πχ. εμβολιασμός 27-12-2020 διαρκεί μέχρι και 24-06-2021).
- Όταν το monitor λάβει σήμα SIGUSR1, αφού το χειριστεί (κάνει set το flag newVaccinationRecords και ύστερα τον αντίστοιχο έλεγχο) θα πρέπει να ψάξει τα αρχεία
  των χωρών για τις οποίες είναι υπεύθυνο και να δεί αν κάποιο από αυτά δεν είναι στην λίστα oldCountryFiles και άρα θα πρέπει να το διαβάσει ως είσοδο.
- Όταν ο travelMonitor λάβει /exit ή ισοδύναμα SIGINT/SIGQUIT πρωτού στείλει SIGKILL στα monitors, τους στέλνει σήμα SIGINT ώστε να γράψουν τα log_file τους.
- Πέρα από τα σήματα SIGINT/SIGQUIT και SIGCHLD που ο χειρισμός τους ζητείται από την εκφώνηση, ο travelMonitor χειρίζεται επίσης το σήμα SIGUSR1. Με αυτόν τον
  τρόπο κάθε monitor γνωστοποιεί ότι έγραψε log_file.xxx (αφού έλαβε SIGINT/SIGQUIT) ώστε ο travelMonitor να στείλει SIGKILL χωρίς το φόβο διακοπής του.
- Ο τερματισμός ενός monitor έχει ως αποτέλεσμα ο travelMonitor να λάβει SIGCHLD. Ο handler για αυτό το σήμα, θέτει το flag monitorTerminated σε 1. Αν το flag
  regeneration είναι επίσης ενεργοποιημένο, στον επόμενο σχετικό έλεγχο όλα τα monitor process που τερματίστηκαν επαναδημιουργούνται. Για να δειχθεί και αυτό το 
  ζητούμενο, έχω προσθέσει μια επιπλέον εντολή /killMonitors.
- Να σημειωθεί ότι με την εντολή /killMonitors οι διεργασίες τερματίζονται και κατά συνέπεια γίνονται reset οι μετρητές αιτημάτων των monitors. Αυτό φαίνεται
  στα log_files που δημιουργούνται.

Μεταγλώττιση:
make (χρήση του Makefile)

Εκτέλεση Προγράμματος:
./travelMonitor -m 10 -b 512 -s 100000 -i input_dir

Εκτέλεση bash script:           (Για 5k εγγραφές ~9mins στο linux07 της σχολής)
./create_infiles.sh inputFile input_dir 3